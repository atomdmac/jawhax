var TiledMap = function (json, options) {
    
    var self  = this,
        _json = json,
        _assets = new jaws.Assets();
        
    this.__defineGetter__("assets", function () {
        return _assets;
    });
    
    this.getMapSize = function () {
        return {
            width : _json.width,
            height: _json.height
        }
    }
    
    this.getCellSize = function () {
        return {
            width : _json.tilewidth,
            height: _json.tileheight
        }
    }
    
    this.getLayer = function (name) {
        var len = _json.layers.length,
            i   = 0;
        for (i; i<len; i++) {
            if (_json.layers[i].name === name) {
                return _json.layers[i];
            }
        }
        throw("Layer '" + layerName + "' not found.");
    },
    
    /**
     * Search through a layer's object and return the first one that matches the
     * given criteria.  By default, the search field is "name".
     *
     * @param layerName {String} Name/ID of the layer to search.
     * @param matchValue {String} The value to match.
     * @param field {String} The field on each object to search.  Defaults to "name".
     * @return Object
     */
    this.getObject = function (layerName, matchValue, field) {
        var layer      = this.getLayer(layerName),
            returnVals = [];
            field      = field || "name";
        
        if (layer.type !== "objectgroup") {
            throw("Layer '" + layerName + "' is not an Object Layer.");
        } else {
            var objs = layer.objects,
                i    = 0,
                len  = objs.length;
            for (i; i<len; i++) {
                if (objs[i][field] === objName) {
                    returnVals.push( objs[i] );
                }
            }
            return returnVals;
        }
    };
    
    /**
     * Return the tileset object that contains the tile with the given GID.
     *
     * @param tilegid {Number}
     * @return Object
     */
    
    // Cache results as each query is made so we can look them up faster later.
    var _tileSetsCache = {};
    this.getTileSet = function (tilegid) {
        if (!_tileSetsCache[tilegid]) {
            var tileSets = _json.tilesets,
                len      = tileSets.length,
                i        = 0,
                // Return FALSE if tile set can't be found.
                returnTileSet = false;
            
            // Since we sorted the tile sets in order of their "firstgid" properties
            // we know that we can stop as soon as we find a "gid" that is larger
            // than the given one.
            for (i; i<len; i++) {
                if (tileSets[i].firstgid <= tilegid) {
                    returnTileSet = tileSets[i];
                } else {
                    break;
                }
            }
            if (!returnTileSet) {
                return false;
            } else {
                _tileSetsCache[tilegid] = returnTileSet;
            }
        }
        return _tileSetsCache[tilegid];
    };
    
    /**
     * Return the image associated with the given tile.
     *
     * @param tilegid {Number}
     * @return Canvas
     */
    // Cache results as each query is made so we can look them up faster later.
    var _tileImagesCache = {};
    this.getTileImage = function (tilegid) {
        if (!_tileImagesCache[tilegid]) {
            var ts     = this.getTileSet(tilegid);
            if (!ts.spriteSheet) debugger;
            var frames = ts.spriteSheet.frames,
                index  = tilegid - ts.firstgid;
            if (index >= 0) {
                _tileImagesCache[tilegid] = frames[index];
            } else {
                throw ("No such sprite found with gid '" + tilegid + "'");
            }
        }
        return _tileImagesCache[tilegid];
    }
    
    /**
     * Return the value of the given property for the given tile on the given
     * layer.  These values are pulled from the "tileproperties" object in the
     * tile set objects (if you're looking at the JSON generated by the Tiled
     * map editor).
     *
     * @param x {Number}
     * @param y {Number}
     * @param layerName {String}
     * @param propertyName {String}
     * @return Object
     */
    this.getTileProperty = function (x, y, layerName, propertyName) {
        var layer = this.getLayer(layerName);
        var tilegid = layer.data[(x * y) + x];
        var    tileSet      = this.getTileSet(tilegid);
        var    tileProps    = tileSet.tileproperties[tilegid - tileSet.firstgid];
        return tileProps[propertyName];
    }
    
    /*
     * Parse the map data that was passed to the constructor of this object.
     * @private
     */
    function _parseMap () {
        var layers   = _json.layers,
            len      = layers.length,
            i        = 0,
            curLayer = null;
        
        // Sort tilesets so they're in order of "firstgid".
        _json.tilesets.sort(function (a, b) {
            if (a>b) {
                return -1;
            }
            if (b>a) {
                return 1;
            }
            return 0;
        });
        
        // Parse map layers.
        for (i; i<len; i++) {
            curLayer = layers[i];
            // TODO: Parse Object layers, too!
            if (curLayer.type === "tilelayer") {
                _parseTileLayer(curLayer);
            }
            else if (curLayer.type === "objectgroup") {
                _parseObjectLayer(curLayer);
            }
        }
        
        // Alert callback now that loading and parsing has finished.
        if (options && options.onfinish) {
            options.onfinish();
        }
    }
    
    /*
     * Parse the given tile layer by creating a jaws.TileMap object and sprite
     * lists and associating them with the input layer object by creating a new
     * "tileMap" property and storing the resulting jaws.TileMap in it.
     * @private
     */
    function _parseTileLayer (layer) {
        var data = layer.data,
            len  = data.length,
            sprites  = new jaws.SpriteList(),
            cellSize = self.getCellSize(),
            mapSize  = self.getMapSize(),
            tileMap  = new jaws.TileMap({
                "cell_size": [cellSize.width, cellSize.height],
                "size"     : [mapSize.width,  mapSize.height]
            });
        
        var x=0, y=0, i=0;
        for (i; i<len; i++) {
            if (x > mapSize.width - 1) {
                x=0;
                y++;
            }
            
            var curTileSet = self.getTileSet([data[i]]);
            
            // Don't draw passable tiles.
            if (curTileSet.name === "passable" || data[i] === 0) {
                x++;
                continue;
            };
            
            var curImage = self.getTileImage(data[i]);
            
            sprites.push(
                new jaws.Sprite({
                    "image": curImage,
                    "x"    : x * cellSize.width,
                    "y"    : y * cellSize.height
                })
            );
            // Advance X coordinate.
            x++;
        }
        
        console.log("Sprite Length: ", sprites.length);
        
        // Add sprites to jaws.TileMap for this layer.
        tileMap.push(sprites);
        
        // Add reference to jaws.TileMap instance to layer object.
        layer.tileMap = tileMap;
    }
    
    // TODO: Finish _parseObjectLayer
    function _parseObjectLayer(layer) {
        var objects = layer.objects,
            len  = objects.length,
            sprites  = new jaws.SpriteList(),
            cellSize = self.getCellSize(),
            mapSize  = self.getMapSize(),
            tileMap  = new jaws.TileMap({
                "cell_size": [cellSize.width, cellSize.height],
                "size"     : [mapSize.width,  mapSize.height]
            });
    }
    
    /*
     * Provide a convenient, reusable way to modify the URLs that are read from
     * the map JSON.  Since the Tiled map editor uses relative paths when
     * referencing tile sets and other external resources, we need to reorient
     * those URLs so they are relative to the game engine instead of the Tiled
     * map file (TMX).
     * @private
     */
    function _formatImageUrl(urlStr) {
        return urlStr.substr(3);
    }
    
    /*
     * Load map assets/tile sets
     * @private
     */
    function _loadAssets(tileSets) {
        var curTile = null,
            len     = tileSets.length,
            i       = 0,
            imgUrl;
        for (i; i<len; i++) {
            imgUrl = tileSets[i].image;
            imgUrl = _formatImageUrl(imgUrl);
            _assets.add(imgUrl);
        }
        _assets.loadAll({
            onfinish: _onAssetsFinish,
            onload  : _onAssetsLoad,
            onerror : _onAssetsError
        })
    }
    
    /*
     * Fired when an individual map asset finishes loading.
     * @private
     */
    function _onAssetsLoad() {
        // TODO: _onAssetsLoad
        console.log("Map asset loaded: ", arguments);
    }
    
    /*
     * Fires when an error occurs with loading a map asset.
     * @private
     */
    function _onAssetsError() {
        // TODO: _onAssetsError
        console.log("Map asset error: ", arguments);
    }
    
    /*
     * Fires when all map assets have finished loading.
     * @private
     */
    function _onAssetsFinish() {
        // TODO: _onAssetsFinish
        console.log("Map assets loaded: ", arguments);
        
        _createSpriteSheets();
        
        _parseMap(_json);
    }
    
    /*
     * Create a jaws.SpriteSheet object for each tileset and store it in a new
     * property called "spriteSheet"
     * @private
     */
    function _createSpriteSheets() {
        var tilesets = _json.tilesets,
            cur      = null,
            i        = 0,
            len      = tilesets.length,
            cellSize = self.getCellSize();
        for (i; i<len; i++) {
            cur = tilesets[i];
            var spriteSheet = new jaws.SpriteSheet({
                "image"      : _assets.get (_formatImageUrl(cur.image) ),
                "frame_size" : [cellSize.width, cellSize.height],
                "orientation": "right"
            });
            cur.spriteSheet = spriteSheet;
        }
    }
    
    // Begin loading and initializing our map data!
    _loadAssets(_json.tilesets);
};